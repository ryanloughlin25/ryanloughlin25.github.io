<!DOCTYPE html>
<head>
  <title>Object Oriented and Functional programming</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet.css">
</head>
<body>
  <div id="blog-container">
    <a href="../index.html" id="home-link">home</a>
    <div id="blog-post">
      <h2>Object Oriented and Functional programming</h2>
      <h4>1/7/2015</h4>
      <p>
        Object oriented programming is a style which centers around classes, objects, and interactions between objects.  Some of the benefits of object oriented programming are encapsulation, inheritance, and polymorphism.  I will give a simple description of each one.  Encapsulation is bundling data and functions together.  These bundles are objects.  Inheritance is a hierarchy of types and subtypes that classify each object.  For example, you might have a food class.  Two subtypes of food could be vegetable and fruit and two subtypes of fruit could be apple and orange.  This way an orange object is an orange, but it is also a fruit and a food.  Polymorphism is taking advantage of the multiple classifications of our orange object.  Sometimes you may want to specifically treat an orange as an orange, but sometimes you may want to separate fruits for vegetables without considering what types of fruit there are.
      </p>
      <p>
        Functional programming is a style which focuses on mathematical formalism.  Functional programming avoids mutable data and changes of state by using functions.  Here function is a formal term meaning a relation between a set of inputs and outputs.  This means that if we run the same code twice then the output should be the same both times.  Reading that it probably sounds obviously true; of course we want code that produces the same output if we run it again.  But many programmers do not follow this rule.  A simple example is <code> x = x + 1 </code>.  If we run <code> x = x + 1 </code> twice then it increments x both times, but the output is different each time.  In fact, out of context, we have no idea what the output of <code> x = x + 1 </code> actually is.  Is x 5?  Or maybe 73?  This isn't necessarily a problem, but it does disagree with most of what is taught in math classes.  If we treat x = x + 1 as an algebra equation it is clearly nonsense.  Subtract x from both the sides and the resulting equation is 0 = 1.  Functional programming encouranges code that follows mathematical formalism.  This might sound odd and overly theoretical, but it tends to be produce simpler code once you get used to it.
      </p>
      <p>
        I will show an example of each style separately and then an example combining the two.  The examples will be about drawing 2 hands from a standard deck of 52 playing cards.  First, here is the output that each program should produce (although the specific cards are random each time):
      </p>
      <pre><code>
my hand is:
Six of Spades
Eight of Spades
Two of Diamonds
Ten of Clubs
Two of Clubs

your hand is:
Three of Clubs
Ace of Clubs
Eight of Clubs
Seven of Clubs
Ace of Hearts
      </pre></code>
        In the object oriented example there will be two classes, Card and Deck, and a few lines to draw and display the cards.  Here is the Card class:
      </p>
      <pre><code>
class Card
  attr_reader :suit, :value

  def initialize(suit, value)
    @suit = suit
    @value = value
  end

  def to_s
    "#{value} of #{suit}s"
  end
end
      </pre></code>
      <p>
        <code>Card</code> is a fairly simple class.  It expects two arguments, <code>suit</code> and <code>value</code>, which should be straightforward.  It has a <code>to_s</code> method so that we can do <code>puts my_card</code> and get a reasonable output.  The <code>Deck</code> class will use the <code>Card</code> class to keep track of its cards:
      </p>
      <pre><code>
class Deck
  SUITS = ['Heart', 'Diamond', 'Club', 'Spade']
  VALUES = [
    'Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven',
    'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King'
  ]

  def initialize
    @cards_in_deck = []
    SUITS.each do |suit|
      VALUES.each do |value|
        @cards_in_deck << Card.new(suit, value)
      end
    end
    @drawn_cards = []
  end

  def shuffle!
    @cards_in_deck.shuffle!

    return self
  end

  def reset_deck
    @cards_in_deck += @drawn_cards
    @drawn_cards.clear
    shuffle

    return self
  end

  def draw(number_of_cards = 1)
    drawn_cards = @cards_in_deck.first(number_of_cards)
    @drawn_cards += drawn_cards
    @cards_in_deck -= drawn_cards

    return drawn_cards
  end
end
      </pre></code>
      <p>
        <code>Deck</code> is more involved.  It has two constants to represent the suits and values of standard playing cards.  <code>initialize</code> expects no arguments and creates two instance variables, <code>@cards_in_deck</code> and <code>@drawn_cards</code>.  <code>@cards_in_deck</code> is initialized to an Array of 52 <code>Card</code> objects and <code>@drawn_cards</code> in initialized to an empty Array.  <code>shuffle</code> and <code>reset_deck</code> are fairly simple.  <code>shuffle</code> randomizes <code>@cards_in_deck</code> and <code>reset_deck</code> puts all the <code>Card</code>s back in <code>@cards_in_deck</code>.  <code>draw</code> accepts a number of cards to draw and moves the first <code>number_of_cards</code> Cards from <code>@cards_in_deck</code> to <code>@drawn_cards</code> and returns those <code>Cards</code>.  This way there is a separation between the cards that are in the deck and the cards that are in a player's hand or otherwise drawn.  Here is a few lines using the <code>Deck</code> class to produce the desired output:
      </p>
      <pre><code>
deck = Deck.new
deck.shuffle!
my_hand = deck.draw(5)
your_hand = deck.draw(5)

puts "my hand is:"
puts my_hand
puts
puts "your hand is:"
puts your_hand
      </pre></code>
      <p>
        Now lets look at a functional style program that produces similar output.  This program is much shorter so I will list all of it at once and then explain it.
      </p>
      <pre><code>
def display_hand(hand)
  hand.each {|(suit, value)| puts "#{value} of #{suit}s"}
end

suits = ['Heart', 'Diamond', 'Club', 'Spade']
values = [
  'Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven',
  'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King'
]

deck = suits.product(values)
my_hand = deck.sample(5)
remaining_deck = deck - my_hand
your_hand = remaining_deck.sample(5)

puts "my hand is:"
display_hand(my_hand)
puts
puts "your hand is:"
display_hand(your_hand)
      </pre></code>
      <p>
        The <code>display_hand</code> method takes an Array representing a hand of cards and puts a reasonable output for each one.  Its purpose is similar to the <code>to_s</code> method in the <code>Card</code> class from the previous example.  Then we have our suits and values again.  The line <code>deck = suits.product(values)</code> creates an Array of 52 Arrays representing the 52 cards by taking the cartesian product of  <code>suits</code> and <code>values</code> (it looks like this <code>[["Heart", "Ace"], ["Heart", "Two"], ["Heart", "Three"], ... ]</code>).  <code>my_hand</code> is created by using <code>sample</code> on <code>deck</code> to get 5 of these "cards".  Next <code>my_hand</code> is removed from <code>deck</code> and <code>your_hand</code> is drawn from the <code>remaining_deck</code>.
      </p>
      <p>
        The functional code was much shorter, but arguably harder to understand. It seems likely that more people will be familiar with classes than cartesian products.  However, as I said before, functional and object oriented styles are not opposites.  Rather they can be used together.  Here is an example of how I would combine object oriented and functional programming to produce the expected output:
      </p>
      <pre><code>
class Card
  attr_reader :suit, :value

  def initialize(suit, value)
    @suit = suit
    @value = value
  end

  def to_s
    "#{value} of #{suit}s"
  end
end

def draw(deck, number_of_cards = 1, *already_drawn)
  remaining_cards = deck - already_drawn.flatten
  drawn_cards = remaining_cards.sample(number_of_cards)

  return drawn_cards
end

suits = ['Heart', 'Diamond', 'Club', 'Spade']
values = [
  'Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven',
  'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King'
]

deck = suits.product(values).map{|(suit, value)| Card.new(suit, value)}
my_hand = draw(deck, 5)
your_hand = draw(deck, 5, my_hand)

puts "my hand is:"
puts my_hand
puts
puts "your hand is:"
puts your_hand
      </pre></code>
      <p>
        The <code>Card</code> class is the same as in the object oriented example.  The suits and values Arrays are the same as in the functional example.  The creation of <code>deck</code> is a combination of the two styles.  I still use the Array created by taking the cartesian product of <code>suits</code> and <code>values</code>.  Then I used <code>map</code> to convert that nested Array to an Array of 52 <code>Card</code> objects.  The result is that <code>deck</code> in this example is the same as <code>@cards_in_deck</code> from the object oriented example.  The <code>draw</code> method is new and deserves some explanation.
      </p>
      <p>
        <code>draw</code> expects 3 parameters.  First, the <code>deck</code> to draw from.  Second, <code>number_of_cards</code> to draw.  And third, any number of additional Arrays of <code>Cards</code> that were already drawn.  It creates an Array, <code>remaining_cards</code>, which contains the <code>Cards</code> in <code>deck</code>, but not the <code>Cards</code> in <code>already_drawn</code>.  Then it uses <code>sample</code> to get <code>number_of_cards</code> <code>Cards</code> from <code>remaining_cards</code> and returns <code>drawn_cards</code>.  This code also produces the expected output.
      </p>
      <p>
        At first glance, this looks like a much more complicated way to do the same thing for the sake of mathematical formalism.  However, there are significant benefits over the other examples.
      </p>
      <p>
        Using the <code>Card</code> class has obvious benefits over writing a <code>display_hand</code> method as it lets us keep track of a thing which has a suit and a value and lets us easily display that thing.
      </p>
      <p>
        Separating <code>deck</code> and <code>draw</code> also has benefits.  In the object oriented example, the <code>Deck</code> class was rather static.  It had the 52 cards and it explicitly kept track of whether each card was drawn.  It modeled a physical deck well by handing out cards, drawing from the top, and being explicitly shuffleable.  But this only makes it easier to think about, it does not actually make the code better.  By separating <code>deck</code> and <code>draw</code> like in the both functional and object oriented example, <code>deck</code> can be used to play many games at the same time.  It doesn't need to be shuffled because it already produces cards at random.  And every time <code>draw(deck)</code> is called it is obvious that it will return 1 of the 52 cards at random, whereas <code>deck.draw</code> had different behavior each time it was called depending on previous calls.
      </p>
      <p>
        Finally the functional style has another rather subtle benefit.  The <code>draw</code> method is actually completely generic if we just rename the variables.  It was written for the explicit purpose of drawing cards from a deck, but nothing about it is specific to a deck of cards.  By using a functional style, I produced generic code without meaning to.  Here is a refactored version:
      </p>
      <pre><code>
def sample_except(array, n = 1, *exception_arrays)
  (array - exception_arrays.flatten).sample(n)
end
      </pre></code>
      <p>
        I have no idea if I will every want to reuse the above method.  But still, having your code end up more generic that you intended is neat.
      </p>
    </div>
  </div>
</body>
