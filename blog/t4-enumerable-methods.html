<!DOCTYPE html>
<head>
  <title>The map method</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet.css">
</head>
<body>
  <div id="blog-container">
    <a href="../index.html" id="home-link">home</a>
    <div id="blog-post">
      <h2>My very own map method</h2>
      <h4>12/11/04</h4>
      <p>
        <code>map</code> executes a block of code for each element in an <code>Enumerable</code> and returns an array containing the result of execute of the block.  <code>map</code> is a lot like <code>each</code> except that <code>map</code> keeps track of what happened, stores it in an array, and returns the array.  For example, it can convert an array of integers to strings.
      </p>
<pre><code>> example_array = [5,3,1,9,3]
=> [5, 3, 1, 9, 3]
>> example_array.map {|n| n.to_s}
=> ["5", "3", "1", "9", "3"]
</code></pre>
      <p>
        <code>map</code> calls <code>to_s</code> on each integer in <code>my_array</code> and returns an <code>Array</code> containing the integers converted to strings.  I think reimplementing a feature yourself is the best way to understand how it works, but we need to understand more about the method call first.  Specifically, how does the <code>{|n| n.to_s}</code> part work?  <code>{|n| n.to_s}</code> is a block.  Blocks are unusual because blocks are one of the few things in Ruby that are not objects, which is probably confusing so let's see an example.
      </p>
<pre><code>>> my_block = {|n| n.to_s}
SyntaxError: (irb):18: syntax error, unexpected '|', expecting '}'
my_block = {|n| n.to_s}
             ^
(irb):18: syntax error, unexpected '}', expecting end-of-input
  from /Users/ryan/.rbenv/versions/2.0.0-p481/bin/irb:12:in `&ltmain&gt'
</code></pre>
      <p>
        I used the same block as when I called map, <code>{|n| n.to_s}</code>, but Ruby has a problem with it now and returns an error.  Ruby won't let us store it in a variable because variables hold objects and a block is not an object.  So how can <code>map</code> handle a block if a simple variable can't?  Methods, such as <code>map</code>, convert the block to a <code>Proc</code>.  For this example we only need to know a few things about <code>Proc</code> (check out the <a href="http://www.ruby-doc.org/core-2.1.5/Proc.html">documention</a> for more info).  <code>Proc</code> is a <code>class</code> so Ruby can make <code>Proc</code> objects and store them in variables, <code>Proc</code> objects include a block, and <code>Proc</code> has a <code>call</code> method which executes the code of the block.  Here is a simple demo of how you can use blocks and <code>Proc</code> objects in methods.
      </p>
<pre><code>>> def do_number_things(&block)
>>   number = 5
>>   block.call(number)
>> end
=> nil
>> do_number_things {|n| n.to_s}
=> "5"
>> do_number_things {|n| n * 2}
=> 10
>> do_number_things {|n| n.even?}
=> false
</code></pre>
      <p>
        Given different blocks as input, <code>do_number_things</code> can produce different output.  <code>{|n| n.to_s}</code> converts 5 to a string, <code>{|n| n * 2}</code> doubles 5, and <code>{|n| n.even?}</code> checks whether 5 is even and it all happened while only writting one method.  There are probably two things about this code that aren't clear.  First, what does the <code>&</code> do?  And, second, what does <code>block.call</code> do?
      </p>
      <p>
        The <code>&</code> has many uses.  In this case it is converting a block, such as <code>{|n| n.to_s}</code>, into a <code>Proc</code>.  This way we can require a <code>Proc</code> as a parameter in the method definition while accepting a block as an argument.  Then we can use the <code>call</code> method to execute the block.  For example, when we call <code>do_number_things {|n| n.to_s}</code>, the line <code>block.call(number)</code> executes the block <code>{|n| n.to_s}</code> with the value of <code>number</code>.  The <code>|n|</code> part of <code>{|n| n.to_s}</code> defines a variable and it gets the value of <code>number</code> because <code>block.call(number)</code> passes <code>number</code> to the block.  Then <code>n.to_s</code> can be execute using the value of <code>number</code> and we get <code>"5"</code>.
      </p>
      <p>
        Now we know enough to implement our own version of <code>map</code>; I will use an <code>Array</code> for the example.  We need a method which uses <code>&</code> to require a <code>Proc</code> as a parameter while accepting a block as an argument.  Then we need to interate over our <code>Array</code>, call the block for each element in the <code>Array</code>, and store the results of the block.  Here's a method <code>my_map</code> as part of the <code>Array class</code> and a simple test.
      </p>
<pre><code>>> class Array
>>   def my_map(&block)
>>     result_array = Array.new
>>     self.each do |element|
?>       result_of_block = block.call(element)
>>       result_array << result_of_block
>>     end
>>     return result_array
>>   end
>> end
=> nil
>> example_array.map {|n| n.to_s}
=> ["5", "3", "1", "9", "3"]
>> example_array.my_map {|n| n.to_s}
=> ["5", "3", "1", "9", "3"]
</code></pre>
      <p>
        As you can see from the last few lines, <code>map</code> and <code>my_map</code> produce the same result.  Now let's walk through each line.  First, <code>my_map</code> creates a new <code>Array</code> and stores it in a variable called <code>result_array</code>.  Next it iterates over <code>self</code> (which is <code>example_array</code> right now) using <code>each</code> and defines a variable called <code>element</code> to store each object as it iterates.  On each iteration the code <code>block.call(element)</code> executes <code>{|n| n.to_s}</code> by binding <code>element</code> to <code>n</code>, which gives us the same result as if we ran <code>element.to_s</code>.  That value is then stored in the variable <code>result_of_block</code>.  Then the value we just stored in <code>result_of_block</code> is saved by using <code><<</code> to add it to <code>result_array</code>.  Finally, it returns <code>return_array</code>.
      </p>
      <p>
        It's a long explanation for a few lines of code.  I want to be as explicit as possible because I think these concepts can be confusing the first time you work with them.  The code can be much shorter and much more concise, but I think it would be much harder to understand without first seeing the verbose version above.  Here is a shorter, refactored version of <code>my_map</code> and the same simple test.
      </p>
<pre><code>>> class Array
>>   def my_map_refactor &block
>>     self.inject [] {|result, element| result << block.call(element)}
>>   end
>> end
=> nil
>> example_array.map {|n| n.to_s}
=> ["5", "3", "1", "9", "3"]
>> example_array.my_map {|n| n.to_s}
=> ["5", "3", "1", "9", "3"]
>> example_array.my_map_refactor {|n| n.to_s}
=> ["5", "3", "1", "9", "3"]
</code></pre>
    </div>
  </div>
</body>
