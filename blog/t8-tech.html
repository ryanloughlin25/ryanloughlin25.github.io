<!DOCTYPE html>
<head>
  <title>tail recursion</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet.css">
</head>
<body>
  <div id="blog-container">
    <a href="../index.html" id="home-link">home</a>
    <div id="blog-post">
      <h2>tail recursion</h2>
      <h4>1/22/2015</h4>
      <p>
        tail call optimization a technique for particularly long running recursive functions.  First, here is a simple recursive factorial function and example output.
      </p>
      <pre><code>def factorial(n)
  return 1 if n < 2
  n * factorial(n-1)
end

irb(main):007:0> factorial(5)
=> 120
irb(main):008:0> factorial(10)
=> 3628800
irb(main):009:0> factorial(100)
=> 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</code></pre>
      <p>
        Of course, factorials grow quickly and the result of <code>factorial(100)</code> is so large it's hard to read.  (Might as well let it run off the page like that.  It won't really be easier to read if I keep it in the border).  This makes sense, it multiplied 100 numbers together.  So what happens if we keep going?  To save space I will output the number of digits in the factorial instead of the factorial itself.
      </p>
      <pre><code>irb(main):010:0> factorial(100).to_s.length
=> 158
irb(main):011:0> factorial(1000).to_s.length
=> 2568
irb(main):012:0> factorial(10000).to_s.length
SystemStackError: stack level too deep
  from /path/to/irb/workspace.rb:86
Maybe IRB bug!</code></pre>
      <p>
        So <code>factorial(100)</code> is 158 digits and <code>factorial(1000)</code> is 2568 digits.  What happened to factorial(10000)?  Too many digits?  Well no the computer can handle multiplying 10000 numbers together, but the factorial function didn't just multiply 10000 numbers.  It also created 10000 function calls - one for each number - and tried to keep them in memory until they were all complete.  Thats what it means by <code>stack level too deep</code>.  (IRB is nice enough to worry that it caused the error, but this isn't IRB's fault).  This is where tail call optimization helps.  Here is a factorial function that is tail recursive.
      </p>
      <pre><code>
def factorial_tco(n, accumulator=1)
  return accumulator if n.zero?
  factorial_tco(n-1, accumulator*n)
end
      </code></pre>
      <p>
        Tail recursive means that each function returns another function call rather than returning an expression than includes the recursive call.  The most obvious difference is that the function now accepts a parameter for the accumulated result.  The compiler can use a function like this with tail call optimization, which allows it to avoid keeping those 10000 functions call in memory all at once.  However, tail call optimization is not enabled by default in Ruby.  Here's how to compile this function with tail call optimization.
      </p>
      <pre><code>
factorial_tco = <<-function
def factorial_tco(n, accumulator=1)
  return accumulator if n.zero?
  factorial_tco(n-1, accumulator*n)
end
function

options = {
  tailcall_optimization: true,
  trace_instruction: false,
}
RubyVM::InstructionSequence.new(factorial_tco, nil, nil, nil, options).eval
      </code></pre>
      <p>
        In case you aren't familiar with it the <code><<-function</code> notation creates a multiline string in Ruby which ends again at <code>function</code>.  You can use another word instead of <code>function</code>, it's just a token to let Ruby know where the string ends.  options is a Hash containing the changes we need to enable tail call optimization.  The last line looks complicated.  It is creating an instruction sequence using the string factorial_tco and evaulating the instruction sequence.  It's basically a fancy way of saying create a program out of this string and run it, but this way it runs with specific options instead of the default settings.  The overall result is just that it creates a factorial_tco function like a normal def block would.  Now the factorial_tco function can calculate larger factorials without a stack depth error.  Although it might take a while for particularly large numbers.
      </p>
      <pre><code>
irb(main):027:0> factorial_tco(100).to_s.length
=> 158
irb(main):028:0> factorial_tco(10000).to_s.length
=> 35660
irb(main):030:0> factorial_tco(100000).to_s.length
=> 456574
      </pre></code>
    </div>
  </div>
</body>
